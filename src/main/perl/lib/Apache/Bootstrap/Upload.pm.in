package Apache::Bootstrap::Upload;

# mod_perl handler for uploading files

use strict;
use warnings;

# make them available, but don't import them
use Apache2::Const -compile => qw(
  HTTP_UNAUTHORIZED
  HTTP_FORBIDDEN
  HTTP_BAD_REQUEST
  NOT_FOUND OK
  SERVER_ERROR
  FORBIDDEN
  DECLINED
  REDIRECT
);

use constant {
  BAD_REQUEST       => Apache2::Const::HTTP_BAD_REQUEST,
  DECLINED          => Apache2::Const::DECLINED,
  FORBIDDEN         => Apache2::Const::FORBIDDEN,
  HTTP_UNAUTHORIZED => Apache2::Const::HTTP_UNAUTHORIZED,
  NOT_FOUND         => Apache2::Const::NOT_FOUND,
  OK                => Apache2::Const::OK,
  REDIRECT          => Apache2::Const::REDIRECT,
  SERVER_ERROR      => Apache2::Const::SERVER_ERROR,
};

use Carp;
use CGI;
use Class::Accessor::Fast;
use Data::Dumper;
use Data::UUID;
use Date::Format qw(time2str);
use Digest::MD5  qw(md5_hex);
use English      qw(-no_match_vars);
use File::Copy;
use File::Basename qw(fileparse);
use JSON;
use List::Util           qw(pairs);
use Log::Log4perl        qw(:easy);
use Number::Bytes::Human qw(format_bytes);
use Redis;
use Template;
use Time::HiRes qw(gettimeofday);

use Readonly;

Readonly our $CONFIG_PATH => '/var/www/config';

Readonly our $TRUE  => 1;
Readonly our $FALSE => 0;

Readonly our $SUCCESS => 0;
Readonly our $FAILURE => 1;

Readonly our $EMPTY       => q{};
Readonly our $SLASH       => q{/};
Readonly our $EQUALS_SIGN => q{=};

Readonly::Hash our %LOG_LEVELS => (
  error => $ERROR,
  warn  => $WARN,
  info  => $INFO,
  debug => $DEBUG,
  trace => $TRACE,
);

Readonly::Hash our %HTTP_CODES => (
  OK           => 200,
  BAD_REQUEST  => 400,
  UNAUTHORIZED => 401,
  FORBIDDEN    => 403,
  SERVER_ERROR => 500,
);

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolation)

{
  my $config;

########################################################################
  sub get_config {
########################################################################
    my ($program_name) = @_;

    return $config
      if $config;

    $config = _get_config($program_name);

    return $config;
  }
}

{
  my $redis;

########################################################################
  sub get_redis_handler {
########################################################################
    my ( $r, $config ) = @_;

    #    return $redis
    #      if $redis;

    $r->log->info( 'initializing Redis connection:', $PID );

    my $redis = eval {
      return Redis->new(
        server => sprintf '%s:%s',
        @{ $config->{redis} }{qw(server port)}
      );
    };

    if ( !$redis || $EVAL_ERROR ) {
      $r->log_error( 'could not initialize redis client: ' . $EVAL_ERROR );
    }

    return $redis;
  }
}

########################################################################
sub set_apache_error {
########################################################################
  my ( $r, $error ) = @_;

  $r->status($error);

  return $error;
}

{
  my $logger;

########################################################################
  sub init_logger {
########################################################################
    my ( $r, $config ) = @_;

    return $logger
      if $logger;

    $r->log->info( 'initializing Log::Log4perl logger:', $PID );

    Log::Log4perl->easy_init(
      { level  => $LOG_LEVELS{ $config->get_log->{level} // 'info' },
        layout => $config->get_log->{layout} // '[%d] (%r/%R) %M:%L - %m%n',
        file   => $config->get_log->{file},
      }
    );

    $logger = Log::Log4perl->get_logger();

    return $logger;
  }
}

########################################################################
sub handler {
########################################################################
  my ($r) = @_;

  my $config = get_config('upload.cgi');

  return set_apache_error( $r, SERVER_ERROR )
    if !$config;

  my $logger = init_logger( $r, $config );

  $logger->debug( Dumper($config) );

  my $redis = get_redis_handler( $r, $config );

  return set_apache_error(SERVER_ERROR)
    if !$redis;

  $r->log->info( "method: ", $r->method );
  $r->log->info( "uri: ",    $r->uri );

  if ( $r->method eq 'GET' ) {
    api_request(
      $r,
      redis  => $redis,
      config => $config,
      logger => $logger,
    );
  }
  else {
    upload(
      $r,
      redis  => $redis,
      config => $config,
      logger => $logger,
    );
  }

  return OK;
}

########################################################################
sub http_error {
########################################################################
  my ( $error, $message ) = @_;

  my $code = $HTTP_CODES{$error};

  if ( !$message ) {
    $error = ucfirst lc $error;
    $error =~ s/_(.)/ \u$1/xsmg;
  }

  return print "Status: $code $error\n\n";
}

########################################################################
sub api_request {
########################################################################
  my ( $r, %args ) = @_;

  my $redis  = $args{redis};
  my $logger = $args{logger};
  my $config = $args{config};

  my $cgi = CGI->new;

  my $session_id = eval { get_session_id($config) // uuid(); };

  if ( !$session_id || $EVAL_ERROR ) {
    return set_apache_error(HTTP_UNAUTHORIZED);
  }

  my $uri = $r->uri;

  my $action = $cgi->param('action');
  $action //= 'show';

  my $extra = $EMPTY;

  if ( $uri =~ /^\/upload\/(.*?)$/xsm ) {
    $extra = $1;
  }

  # /upload/status
  if ( $extra eq 'status' ) {
    $action = 'status';
  }

  $logger->info(
    Dumper(
      [ 'uri'        => $uri,
        'action'     => $action,
        'session_id' => $session_id
      ]
    )
  );

  my %request = (
    'initialize' => \&initialize,
    'finalize'   => \&finalize,
    'status'     => \&status,
    'clear'      => \&clear_cache,
    'show'       => \&show_form,
  );

  if ( !$request{$action} ) {
    return set_apache_error(BAD_REQUEST);
  }

  return $request{$action}->(
    $r,
    %args,
    session_id => $session_id,
    cgi        => $cgi,
  );
}

########################################################################
sub status {
########################################################################
  my ( $r, %args ) = @_;

  my $redis      = $args{redis};
  my $logger     = $args{logger};
  my $config     = $args{config};
  my $cgi        = $args{cgi};
  my $session_id = $args{session_id};

  my $file_list = decode_json( $redis->get($session_id) // '{}' );

  $logger->info( Dumper( [ 'file_list', $file_list ] ) );

  my %status;

  if ( keys %{$file_list} ) {
    my %files;

    for ( keys %{$file_list} ) {
      $files{$_} = decode_json( $redis->get($_) || '{}' );
    }

    $status{files} = \%files;
    $status{error} = $EMPTY;
  }
  else {
    $status{error} = 'not found';
  }

  $logger->info( Dumper( \%status ) );

  return output_json( $r, \%status );
}

########################################################################
sub clear_cache {
########################################################################
  my ( $r, %args ) = @_;

  my $redis      = $args{redis};
  my $session_id = $args{session_id};

  my $file_list = decode_json( $redis->get($session_id) // '{}' );

  my $status = eval {
    if ( keys %{$file_list} ) {
      foreach ( keys %{$file_list} ) {
        $redis->del($_);
      }
    }

    $redis->del($session_id);

    return { success => $session_id };
  };

  if ( $status || $EVAL_ERROR ) {
    $status = { error => $EVAL_ERROR || 'unknown error' };
  }

  return output_json( $r, $status );
}

########################################################################
sub initialize {
########################################################################
  my ( $r, %args ) = @_;

  my $redis      = $args{redis};
  my $logger     = $args{logger};
  my $config     = $args{config};
  my $cgi        = $args{cgi};
  my $session_id = $args{session_id};

  my $file_map = {};

  my @ts = gettimeofday();

  my @files;

  my $size      = $cgi->param('size');
  my $filename  = $cgi->param('filename') // $EMPTY;
  my $file_list = $cgi->param('file_list');         # array of file objects
  my $index     = $cgi->param('index');

  if ($file_list) {
    @files = @{ serialize($file_list) };
  }
  else {
    push @files,
      {
      filename => $filename,
      size     => $size,
      index    => $index,
      };
  }

  $logger->debug( sub { return Dumper( [@files] ) } );

  for (@files) {
    my $file_id = md5_hex( $_->{filename}, $session_id );

    my $status = {
      session_id => $session_id,
      filename   => $_->{filename},
      size       => $_->{size},
      index      => $_->{index},
      init_time  => \@ts,
      size_human => format_bytes( $_->{size} ),
    };

    $file_map->{$file_id} = $status;

    $redis->set( $file_id, serialize($status) );
  }

  $redis->set( $session_id, serialize($file_map) );

  expire_upload(
    key    => $session_id,
    type   => 'session',
    config => $config,
    redis  => $redis
  );

  $logger->info( sub { return Dumper( [$file_map] ) } );

  return output_json( $r, $file_map );
}

########################################################################
sub upload {
########################################################################
  my ( $r, %args ) = @_;

  $r->log->info( Dumper( [ args => \%args ] ) );

  my $redis  = $args{redis};
  my $logger = $args{logger};
  my $config = $args{config};

  my $session_id = get_session_id($config);

  if ( !$session_id ) {
    $r->status(FORBIDDEN);

    return FORBIDDEN;
  }

  my @start_time = gettimeofday();

  my $start_time_microseconds = $start_time[0] * 1_000_000 + $start_time[1];

  my $cgi = CGI->new(
    \&hook,
    { logger     => $logger,
      redis      => $redis,
      start_time => $start_time_microseconds,
      session_id => $session_id,
      config     => $config,
    },
    $FALSE,
  );

  my $status = serialize( $redis->get($session_id) || {} );

  my $filename = $cgi->upload('filename');

  my $file_id   = md5_hex( "$filename", $session_id );
  my $file_info = serialize( $redis->get($file_id) );

  $logger->info(
    Dumper(
      [ 'file_info', $file_info,  'status', $status,
        'filename',  "$filename", 'cgi',    $cgi
      ]
    )
  );

  my $account_id = get_account_id($session_id);
  $logger->info( sprintf 'uploading file for account: [%d], session: [%s]',
    $account_id, $session_id );

  if ($filename) {
    $file_info->{temp_filename} = $filename->filename;

    my $src  = $filename->filename;
    my $dest = sprintf '%s/%s-%s', $config->get_upload->{path}, $account_id,
      $filename;

    $logger->info( sprintf 'copying %s to %s', $src, $dest );

    if ( !copy $src, $dest ) {
      $logger->error( 'error copying file: %s to %s', $src, $dest );
    }

    unlink $src;

    $file_info = serialize($file_info);
  }
  else {
    $file_info = serialize( { error => 'not sure what happened here?' } );
  }

  return output_json( $r, $file_info );
}

########################################################################
sub serialize {
########################################################################
  my ($obj) = @_;

  return ref $obj ? encode_json($obj) : decode_json($obj);
}

########################################################################
sub get_session_id {
########################################################################
  my ($config) = @_;

  my $cookie_name = $config->get_session->{cookie_name};

  my ($session_id) = grep {/$cookie_name/xsm} split /;/xsm,
    $ENV{HTTP_COOKIE} // $EMPTY;

  return
    if !$session_id;

  if ($session_id) {
    $session_id = ( split /=/xsm, $session_id )[1];
  }

  return $session_id;
}

########################################################################
sub hook {
########################################################################
  my ( $filename, $buffer, $bytes_read, $data ) = @_;

  my $logger     = $data->{logger};
  my $redis      = $data->{redis};
  my $config     = $data->{config};
  my $session_id = $data->{session_id};

  my $file_id = md5_hex( $filename, $session_id );

  $logger->info("fetching $file_id");

  my $status = $redis->get($file_id) || '{}';

  $status = serialize($status);

  my $start_time_microseconds = $data->{start_time};

  my @now_time = gettimeofday();

  my $now_time_microseconds = $now_time[0] * 1_000_000 + $now_time[1];

  my $elapsed_time = $now_time_microseconds - $start_time_microseconds;
  $elapsed_time = $elapsed_time > 0 ? int( $elapsed_time / 1_000 ) : 0;

  $status->{bytes_read}             = $bytes_read;
  $status->{elapsed_time}           = $elapsed_time;
  $status->{elapsed_time_formatted} = sprintf '%5.3f', $elapsed_time / 1000;
  $status->{pid}                    = $PID;
  $status->{percent_complete}       = int 100 * $bytes_read / $status->{size};

  $logger->trace( "setting $file_id to " . serialize($status) );

  $redis->set( $file_id, serialize($status) );

  expire_upload(
    key    => $file_id,
    type   => 'file',
    config => $config,
    redis  => $redis
  );

  expire_upload(
    key    => $session_id,
    type   => 'session',
    config => $config,
    redis  => $redis
  );

  $logger->trace(
    Dumper(
      [ length($buffer), $filename, $bytes_read, $ENV{CONTENT_LENGTH}, ]
    )
  );

  return $TRUE;
}

########################################################################
sub expire_upload {
########################################################################
  my (%args) = @_;

  my $redis  = $args{redis};
  my $config = $args{config};
  my $key    = $args{key};
  my $type   = $args{type};

  my $timeout = time + $config->get_upload->{timeout}->{$type};

  return $redis->expireat( $key, $timeout );
}

########################################################################
sub output_json {
########################################################################
  my ( $r, $json ) = @_;

  if ( ref $json ) {
    $json = encode_json($json);
  }

  $r->content_type('application/json');
  $r->send_http_header;

  print $json;

  return OK;
}

########################################################################
sub show_form {
########################################################################
  my ( $r, %args ) = @_;

  my $session_id = $args{session_id};
  my $config     = $args{config};

  my $tt = Template->new(
    { INCLUDE_PATH => $config->get_template->{include_path},
      ABSOLUTE     => $config->get_template->{absolute},
      INTERPOLATE  => $config->get_template->{interpolate},
    }
  );

  my $parameters = { session_id => $session_id };

  my $content  = $EMPTY;
  my $template = $config->{template}->{'upload-form'};

  $tt->process( $template, $parameters, \$content );
  $content ||= '<pre>error: ' . $tt->error() . '</pre>';

  my $expiry_date
    = time2str( '%a, %d-%b-%Y %H:%M:%S GMT', time + 60 * 60 * 15 );

  my $cookie_name = $config->get_session->{cookie_name};

  my %headers_out = $r->headers_out;

  $headers_out{'Set-Cookie'} = bake_cookie(
    $cookie_name => $session_id,
    SameSite     => $EMPTY,
    Secure       => undef,
    path         => $SLASH,
    expires      => $expiry_date,
  );

  $r->content_type('text/html');
  $r->send_http_header;

  return print "\n$content";
}

########################################################################
sub uuid {
########################################################################
  my $ug = Data::UUID->new;

  return $ug->to_string( $ug->create() );
}

########################################################################
sub _get_config {
########################################################################
  my ($config_name) = @_;

  my ( $name, $path, $ext ) = fileparse( $config_name, qr{[.][^.]+$}xsm );

  my $config_path = $ENV{CONFIG_PATH} || $CONFIG_PATH;

  my $config_file = $CONFIG_PATH . "/$name.json";

  local $RS = undef;

  open my $fh, '<', $config_file
    or croak "could not open $config_file";

  my $config = eval { return decode_json(<$fh>); };

  close $fh;

  croak "invalid configuration file\n$EVAL_ERROR"
    if !$config;

  bless $config, 'Apache::Upload::Config';

  {
    no strict 'refs'; ## no critic (ProhibitNoStrict)

    use Class::Accessor::Fast;

    @{'Apache::Upload::Config::ISA'} = qw(Class::Accessor::Fast);
  }

  $config->follow_best_practice();
  $config->mk_ro_accessors( keys %{$config} );

  return $config;
}

########################################################################
sub get_account_id {
########################################################################
  my ($session_id) = @_;

  # todo: use session_id to lookup account in table...
  return '1';
}

########################################################################
sub bake_cookie {
########################################################################
  my (@cookie) = @_;

  my $cookie = join '; ',
    map { defined $_->[1] ? $_->[0] . $EQUALS_SIGN . $_->[1] : $_->[0] }
    pairs @cookie;

  return $cookie;
}

1;

__END__
